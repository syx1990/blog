[{"title":"laravel性能优化方案","url":"/2019/12/27/laravel性能优化方案/","content":"> https://segmentfault.com/a/1190000011569012\n\n> [上线清单 —— 20 个 Laravel 应用性能优化项 - PHP / Laravel / 全栈 - SegmentFault 思否](https://segmentfault.com/a/1190000018339912)","tags":["Laravel"]},{"title":"Laravel 使用 Jwt-Auth 实现 API 用户认证以及无痛刷新访问令牌","url":"/2019/12/27/Laravel-使用-Jwt-Auth-实现-API-用户认证以及无痛刷新访问令牌/","content":"[Laravel 5.5 使用 Jwt-Auth 实现 API 用户认证以及无痛刷新访问令牌 - Artisan - SegmentFault 思否](https://segmentfault.com/a/1190000012606246#comment-area)","tags":["Laravel"]},{"title":"Laravel框架基于ajax实现二级联动功能","url":"/2019/12/27/Laravel框架基于ajax实现二级联动功能/","content":"> [Laravel框架基于ajax实现二级联动功能示例_PHP编程_网络编程 - 编程客栈](http://www.cppcns.com/wangluo/php/250165.html)","tags":["Laravel"]},{"title":"laravel集成debugbar方案","url":"/2019/12/27/aravel集成debugbar方案/","content":"* composer即成debugbar\n```bash\ncomposer require barryvdh/laravel-debugbar\n```\n* If you don’t use auto-discovery, add the ServiceProvider to the providers array in config/app.php\n```bash\nBarryvdh\\Debugbar\\ServiceProvider::class,\n```\n* If you want to use the facade to log messages, add this to your facades in app.php:\n```bash\n'Debugbar' => Barryvdh\\Debugbar\\Facade::class,\n```\n* Copy the package config to your local config with the publish command:\n```bash\nphp artisan vendor:publish --provider=\"Barryvdh\\Debugbar\\ServiceProvider\"\n```\n","tags":["Laravel"]},{"title":"Laravel5.5 开发 API 实战","url":"/2019/12/27/Laravel5-5-开发-API-实战/","content":"Laravel5.5更新，通过Laravel5.5开发Api更加顺畅了，在这里就分享一下Laravel开发Api的经验吧\n> https://www.timenotes.me/articles/code/11/laravel55-development-of-api-actual-combat\n* 封装返回的统一消息\n\n返回的自定义消息，和错误消息，我自己封装了一个Trait，用来做基本的返回，Trait的封装如下\n\n```php\n<?php\n\n\nnamespace App\\Api\\Helpers\\Api;\n\nuse Symfony\\Component\\HttpFoundation\\Response as Foundationresponse;\nuse Response;\n\ntrait ApiResponse\n{\n\n    /**\n     * @var int\n     */\n    protected $statusCode = Foundationresponse::HTTP_OK;\n\n    /**\n     * @return mixed\n     */\n    public function getStatusCode()\n    {\n        return $this->statusCode;\n    }\n\n/**\n     * @param $statusCode\n     * @return $this\n     */\n    public function setStatusCode($statusCode)\n    {\n\n        $this->statusCode = $statusCode;\n        return $this;\n    }\n\n    /**\n     * @param $data\n     * @param array $header\n     * @return mixed\n     */\n    public function respond($data, $header = [])\n    {\n\n        return Response::json($data,$this->getStatusCode(),$header);\n    }\n     \n    /**\n     * @param $status\n     * @param array $data\n     * @param null $code\n     * @return mixed\n     */\n    public function status($status, array $data, $code = null){\n\n        if ($code){\n            $this->setStatusCode($code);\n        }\n\n        $status = [\n            'status' => $status,\n            'code' => $this->statusCode\n        ];\n\n        $data = array_merge($status,$data);\n        return $this->respond($data);\n\n    }\n\n    /**\n     * @param $message\n     * @param int $code\n     * @param string $status\n     * @return mixed\n     */\n    public function failed($message, $code= Foundationresponse::HTTP_BAD_REQUEST, $status = \"error\"){\n\n        return $this->status($status,[\n            'message' => $message\n        ],$code);\n    }\n\n\n    /**\n     * @param $message\n     * @param string $status\n     * @return mixed\n     */\n    public function message($message, $status = \"success\"){\n\n        return $this->status($status,[\n            'message' => $message\n        ]);\n    }\n     \n    /**\n     * @param string $message\n     * @return mixed\n     */\n    public function internalError($message = \"Internal Error!\"){\n\n        return $this->setStatusCode(Foundationresponse::HTTP_INTERNAL_SERVER_ERROR)\n            ->failed($message);\n    }\n\n    /**\n     * @param string $message\n     * @return mixed\n     */\n    public function created($message = \"created\")\n    {\n        return $this->setStatusCode(Foundationresponse::HTTP_CREATED)\n            ->message($message);\n\n    }\n\n        /**\n     * @param $data\n     * @param string $status\n     * @return mixed\n     */\n    public function success($data, $status = \"success\"){\n\n        return $this->status($status,compact('data'));\n    }\n\n    /**\n     * @param string $message\n     * @return mixed\n     */\n    public function notFond($message = 'Not Fond!')\n    {\n        return $this->setStatusCode(Foundationresponse::HTTP_NOT_FOUND)->failed($message);\n    }\n}\n```\n然后创建一个ApiController,通过所有的Api控制器继承该控制器,实现简洁的Api返回\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Api\\Helpers\\Api\\ApiResponse;\nuse App\\Http\\Controllers\\Controller;\n\n\nclass ApiController extends Controller\n{\n\n    use ApiResponse;\n\n    // 其他通用的Api帮助函数\n\n}\n```\n然后，Api控制器就可以简洁的返回\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nclass IndexController extends ApiController\n{\n    public function index(){\n\n        return $this->message('请求成功');\n    }\n}\n```\n\n* 资源类型的返回\n\n资源返回通过5.5的新特性,API资源实现,具体参见 https://d.laravel-china.org/docs/5.5/eloquent-resources 使用方面比之前的Transformer方式更好用更优雅 比如返回用户的分页数据，只需要这样 文档已经很详细了，这里不再做概述\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\Api;\nuse App\\Models\\User;\nuse App\\Http\\Resources\\User as UserCollection;\nuse Illuminate\\Support\\Facades\\Input;\n\n\nclass IndexController extends ApiController\n{\n    public function index(){\n\n        return UserCollection::collection(User::paginate(Input::get('limit') ?: 20));\n\n    }\n}\n```\n* Api授权模块\n\n这里直接抛弃之前的jwt转向passport的认证方式,之前论坛已经有相关认证的帖子了 这里通过重写AuthenticatesUsers通过password的的授权模式模式进行实现\n```php\n<?php\nnamespace App\\Http\\Controllers\\Api;\n\n\nuse Carbon\\Carbon;\nuse Illuminate\\Foundation\\Auth\\AuthenticatesUsers;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Laravel\\Passport\\Client;\nuse Socialite;\n\nuse App\\Models\\User;\nuse Illuminate\\Http\\Request;\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\nuse Validator;\n\n\nclass AuthenticateController extends ApiController\n{\n\n    use AuthenticatesUsers;\n\n    public function __construct()\n    {\n        $this->middleware('auth:api')->only([\n            'logout'\n        ]);\n    }\n\n    public function username()\n    {\n        return 'phone';\n    }\n\n    // 登录\n    public function login(Request $request)\n    {\n        $validator = Validator::make($request->all(), [\n            'phone'    => 'required|exists:user',\n            'password' => 'required|between:5,32',\n        ]);\n\n        if ($validator->fails()) {\n            $request->request->add([\n                'errors' => $validator->errors()->toArray(),\n                'code' => 401,\n            ]);\n            return $this->sendFailedLoginResponse($request);\n        }\n\n        $credentials = $this->credentials($request);\n\n        if ($this->guard('api')->attempt($credentials, $request->has('remember'))) {\n            return $this->sendLoginResponse($request);\n        }\n\n        return $this->setStatusCode(401)->failed('登录失败');\n    }\n\n    // 退出登录\n    public function logout(Request $request)\n    {\n\n        if (Auth::guard('api')->check()){\n\n            Auth::guard('api')->user()->token()->revoke();\n\n        }\n\n        return $this->message('退出登录成功');\n\n    }\n\n    // 第三方登录\n    public function redirectToProvider($driver) {\n\n        if (!in_array($driver,['qq','wechat'])){\n\n            throw new NotFoundHttpException;\n        }\n\n        return Socialite::driver($driver)->redirect();\n    }\n\n\n    // 第三方登录回调\n    public function handleProviderCallback($driver) {\n\n        $user = Socialite::driver($driver)->user();\n\n        $openId = $user->id;\n\n\n     // 第三方认证\n        $db_user = User::where('xxx',$openId)->first();\n\n        if (empty($db_user)){\n\n            $db_user = User::forceCreate([\n                'phone' => '',\n                'qqUnionId' => $openId,\n                'nickname' => $user->nickname,\n                'head' => $user->avatar,\n            ]);\n\n        }\n\n        // 直接创建token并设置有效期\n        $createToken = $db_user->createToken($openId);\n\n        $createToken->token->expires_at = Carbon::now()->addDays(15);\n        $createToken->token->save();\n\n        $token = $db_user->createToken($openId)->accessToken;\n\n        return $this->success(compact('token'));\n\n    }\n\n\n    //调用认证接口获取授权码\n    protected function authenticateClient(Request $request)\n    {\n        $credentials = $this->credentials($request);\n\n                // 个人感觉通过.env配置太复杂，直接从数据库查更方便\n        $password_client = Client::query()->where('password_client',1)->latest()->first();\n\n        $request->request->add([\n            'grant_type' => 'password',\n            'client_id' => $password_client->id,\n            'client_secret' => $password_client->secret,\n            'username' => $credentials['phone'],\n            'password' => $credentials['password'],\n            'scope' => ''\n        ]);\n\n        $proxy = Request::create(\n            'oauth/token',\n            'POST'\n        );\n\n        $response = \\Route::dispatch($proxy);\n\n        return $response;\n    }\n\n\n\n    protected function authenticated(Request $request)\n    {\n        return $this->authenticateClient($request);\n    }\n\n    protected function sendLoginResponse(Request $request)\n    {\n        $this->clearLoginAttempts($request);\n\n        return $this->authenticated($request);\n    }\n\n    protected function sendFailedLoginResponse(Request $request)\n    {\n        $msg = $request['errors'];\n        $code = $request['code'];\n        return $this->setStatusCode($code)->failed($msg);\n    }\n}\n```\n* 自定义返回异常\n### 这里我的做法是直接拦截\nApp\\Exceptions\\Handler的render方法，实现自定义返回\n\n```php\n<?php\n\nnamespace App\\Exceptions;\n\nuse App\\Api\\Helpers\\Api\\ExceptionReport;\nuse Exception;\nuse Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;\n\nclass Handler extends ExceptionHandler\n{\n    /**\n     *  其他代码...\n     */\n\n    /**\n     * Render an exception into an HTTP response.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Exception  $exception\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function render($request, Exception $exception)\n    {\n        // 将方法拦截到自己的ExceptionReport\n        $reporter = ExceptionReport::make($exception);\n\n        if ($reporter->shouldReturn()){\n            return $reporter->report();\n        }\n\n        return parent::render($request, $exception);\n    }\n}\n```\n\n然后在该方法实现自定义返回\n```php\n<?php\n\nnamespace App\\Api\\Helpers\\Api;\n\n\nuse Exception;\nuse Illuminate\\Auth\\AuthenticationException;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\nuse Illuminate\\Http\\Request;\n\nclass ExceptionReport\n{\n    use ApiResponse;\n\n    /**\n     * @var Exception\n     */\n    public $exception;\n    /**\n     * @var Request\n     */\n    public $request;\n\n    /**\n     * @var\n     */\n    protected $report;\n\n\n    /**\n     * ExceptionReport constructor.\n     * @param Request $request\n     * @param Exception $exception\n     */\n    function __construct(Request $request, Exception $exception)\n    {\n        $this->request = $request;\n        $this->exception = $exception;\n    }\n\n\n    /**\n     * @var array\n     */\n    public $doReport = [\n        AuthenticationException::class => ['未授权',401],\n        ModelNotFoundException::class => ['改模型未找到',404]\n    ];\n\n\n    /**\n     * @return bool\n     */\n    public function shouldReturn(){\n\n        if (! ($this->request->wantsJson() || $this->request->ajax())){\n            return false;\n        }\n\n        foreach (array_keys($this->doReport) as $report){\n\n            if ($this->exception instanceof $report){\n\n                $this->report = $report;\n                return true;\n            }\n        }\n\n        return false;\n    }\n    /**\n     * @param Exception $e\n     * @return static\n     */\n    public static function make(Exception $e){\n\n        return new static(\\request(),$e);\n    }\n\n    /**\n     * @return mixed\n     */\n    public function report(){\n\n        $message = $this->doReport[$this->report];\n\n        return $this->failed($message[0],$message[1]);\n\n    }\n```\n","tags":["Laravel"]},{"title":" Laravel 5.5+ Dingo +Jwt 快速搭建 API系统","url":"/2019/12/27/Laravel-5-5-Dingo-Jwt-快速搭建-API系统/","content":"> [Laravel 5.5+ Dingo +Jwt 快速搭建 API系统-Leesin-51CTO博客](https://blog.51cto.com/12750968/2109459)\n\n* 创建 laravel 项目\n```bash\ncomposer create-project --prefer-dist laravle/laravel myProject  '5.8.*'\n```\n* 安装 Dingo\n```bash\n\"require\":{\n        \"dingo/api\": \"1.0.0-beta8\"\n},\n\"minimum-stability\":\"dev\",\n```\n执行安装\n```bash\ncomposer update\n```\n安装jwt\n```bash\ncomposer require tymon/jwt-auth:dev-develop --prefer-source\n```\n配置项目\nconfig/app.php\n```php\n\"providers\"=>[\n        ...\n        Dingo\\Api\\Provider\\LaravelServiceProvider::class,\n        Tymon\\JWTAuth\\Providers\\LaravelServiceProvider::class,\n],\n'aliases' => [\n    ...\n    'JWTAuth' => Tymon\\JWTAuth\\Facades\\JWTAuth::class，\n        'JWTFactory' => Tymon\\JWTAuth\\Facades\\JWTFactory::class\n]\n```\n发布配置文件 : 终端执行\n\n```bash\nphp artisan vendor:publish --provider=\"Dingo\\Api\\Provider\\LaravelServiceProvider\"  //生成 api.php\nphp artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\LaravelServiceProvider\"  //生成 jwt.php\n\n或者\nphp artisan vendoer:publish \n选择编号即可发布\n```\n生成 JWT_SECRET 写入.env\n```bash\nphp artisan jwt:secret  \n```\nconfig/api.php\n```bash\n'auth' => [\n    'jwt' => Dingo\\Api\\Auth\\Provider\\JWT::class\n]\n```\n在 .env 中，把 dingo 配置在最后\n```bash\nAPI_STANDARDS_TREE=vnd // 环境\nAPI_SUBTYPE=myapp // 子类型\nAPI_PREFIX=api // 前缀\nAPI_DOMAIN=api.myapp.com //子域名  （前缀和子域名只能存在一个）可选\nAPI_VERSION=v1 // 版本\nAPI_NAME=My API // 名字（使用API Blueprint命令才会用到）\nAPI_CONDITIONAL_REQUEST=false // 带条件的请求\nAPI_STRICT=false // Strict模式\nAPI_DEFAULT_FORMAT=json // 响应格式\nAPI_DEBUG=true // 调试模式\n```\n上面的配置不是都是必要的，可根据实际情况进行选择（上面配置时参考网络配置）,如：\n```bash\nAPI_STANDARDS_TREE=vnd\nAPI_SUBTYPE=emall\nAPI_PREFIX=api\nAPI_VERSION=v1\n```\n* 路由：\n在routers/api.php中新建内容，两个路径分别是注册和登录：\n\n```bash\n//接管路由\n$api = app('Dingo\\Api\\Routing\\Router');\n\n$api->version('v1', function ($api) {\n         $api->post('login', 'App\\Http\\Controllers\\Api\\Auth\\LoginController@login');\n         $api->post('register', 'App\\Http\\Controllers\\Api\\Auth\\RegisterController@register');\n});\n```\n生成 Controller\n```bash\nphp artisan make:controller Api/Auth/LoginController\nphp artisan make:controller Api/Auth/RegisterController\n```\n* 数据库配置 .env\n```bash\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=51tbk.com\nDB_USERNAME=root\nDB_PASSWORD=123\n```\n如果不适用laravel 自带的认证系统（php artisan make:auth）会创建模板，可以使用数据迁移\n```bash\nphp artisan make:model User -m   //生成user 模型的同时，创建数据迁移\n单独生成迁移文件\nphp artisan make:migration create_users_table\n```\n修改内容\n```bash\npublic function up()\n{\n    Schema::create('users', function (Blueprint $table) {\n        $table->increments('id');\n        $table->string('name')->unique();\n        $table->string('email')->unique();\n        $table->string('password');\n        $table->rememberToken();\n        $table->timestamps();\n    });\n}\n```\n生成表\n```bash\nphp artisan migrate\n```\n编辑 Model/Users.php\n\n```php\n<?php\n\nnamespace App\\Model;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\nuse Tymon\\JWTAuth\\Contracts\\JWTSubject;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass Users extends Authenticatable implements JWTSubject \n{\n    use Notifiable;\n\n    protected $fillable = ['name','email','password'];\n\n    protected $hidden = ['password','remember_token'];\n\n    public function getJWTIdentifier(){\n        return $this->getKey();\n    }\n\n    public function getJWTCustomClaims(){\n        return [];\n    }\n}\n```\n* 注册 RegisterController.php\n\n```bash\n<?php\n\nnamespace App\\Http\\Controllers\\Api\\Auth;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\User;\nuse Dingo\\Api\\Routing\\Helpers;\nuse Illuminate\\Foundation\\Auth\\RegistersUsers;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Tymon\\JWTAuth\\Facades\\JWTAuth;\n\nclass RegisterController extends Controller {\n    use RegistersUsers;\n    use Helpers;\n\n    public function register(Request $request) {\n\n        $validator = $this->validator($request->all());\n        if ($validator->fails()) {\n            throw new StoreResourceFailedException(\"Validation Error\", $validator->errors());\n        }\n\n        $user = $this->create($request->all());\n\n        if ($user->save()) {\n\n            $token = JWTAuth::fromUser($user);\n\n            return $this->response->array([\n                \"token\" => $token,\n                \"message\" => \"注册成功\",\n                \"status_code\" => 201,\n            ]);\n        } else {\n            return $this->response->error(\"User Not Found...\", 404);\n        }\n    }\n\n    protected function validator(array $data) {\n        return Validator::make($data, [\n            'name' => 'required|unique:users',\n            'email' => 'required|email|max:255|unique:users',\n            'password' => 'required|min:6',\n        ]);\n    }\n\n    protected function create(array $data) {\n        return User::create([\n            'name' => $data['name'],\n            'email' => $data['email'],\n            'password' => bcrypt($data['password']),\n        ]);\n    }\n}\n```\n* 登录 LoginController.php\n\n```php\n<?php\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\User;\nuse Dingo\\Api\\Routing\\Helpers;\nuse Illuminate\\Foundation\\Auth\\AuthenticatesUsers;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Symfony\\Component\\HttpKernel\\Exception\\UnauthorizedHttpException;\nuse Tymon\\JWTAuth\\Facades\\JWTAuth;\n\nclass LoginController extends Controller\n{\n    use AuthenticatesUsers;\n    use Helpers;\n\n    public function login(Request $request) {\n\n        $user = User::where('email', $request->email)->orWhere('name', $request->email)->first();\n\n        if ($user && Hash::check($request->get('password'), $user->password)) {\n            $token = JWTAuth::fromUser($user);\n            return $this->sendLoginResponse($request, $token);\n        }\n\n        return $this->sendFailedLoginResponse($request);\n    }\n\n    public function sendLoginResponse(Request $request, $token) {\n        $this->clearLoginAttempts($request);\n\n        return $this->authenticated($token);\n    }\n\n    public function authenticated($token) {\n        return $this->response->array([\n            'token' => $token,\n            'status_code' => 200,\n            'message' => 'User Authenticated',\n        ]);\n    }\n\n    public function sendFailedLoginResponse() {\n        throw new UnauthorizedHttpException(\"Bad Credentials\");\n    }\n\n    public function logout() {\n        $this->guard()->logout();\n    }\n}\n```\n* 获取用户信息\nroutes/api.php\n\n```php\n$api->group(['middleware' => 'api.auth'], function ($api) {\n    $api->get('user', 'App\\Http\\Controllers\\Api\\UsersController@index');\n});\n\nphp artisan make:controller Api/UsersController\n```\n编辑 UsersController.php\n```bash\n\n```\n每次请求需要加 Header\n```bash\nAuthorization ：Bearer + token\n```","tags":["Laravel"]},{"title":"guzzle中文文档","url":"/2019/12/27/guzzle中文文档/","content":"[概述 — Guzzle中文文档](https://guzzle-cn.readthedocs.io/zh_CN/latest/overview.html)\n\n* 安装\n```bash\ncomposer require guzzlehttp/guzzle:~6.0\n```","tags":["Laravel"]},{"title":"DingoApi开发API接口","url":"/2019/12/27/DingoApi开发API接口/","content":"> [DingoApi - 简书](https://www.jianshu.com/p/cb7da792d91e)\n* 进入项目目录，执行composer安装命令\n```bash\ncomposer require dingo/api\n```\n* 生成配置文件\n```bash\nphp artisan vendor:publish --provider=\"Dingo\\Api\\Provider\\LaravelServiceProvider\"\n```\n执行成功后 config目录生成api.php文件。\n[image:(null)/(null)][image:(null)/(null)]api.php文件的中的配置项可以.env中设置，下面进行基本配置：\n\n```bash\nAPI_STANDARDS_TREE=prs\n```\n*API_STANDARDS_TREE 有是三个值可选*\n*x 本地开发的或私有环境的*\n*prs 未对外发布的，提供给公司 app，单页应用，桌面应用等*\n*vnd 对外发布的，开放给所有用户*\n```bash\nAPI_SUBTYPE=kentcms\n```\n*API_SUBTYPE是我们项目的简称，全小写。*\n*通过以上两项的设置，可使用Accept 头来访问不同API 版方式如下：*\n*访问 v1 版本*\n*Accept: application/prs.kentcms.v1+json*\n*访问 v2 版本*\n*Accept: application/prs.kentcms.v2+json*\n接口访问方式设置：\n```bash\nAPI_PREFIX=api\n```\nAPI_PREFIX用来设置api前缀，如aaaxxxccc.com/api方式访问接口。\n```bash\nAPI_DOMAIN=api.xxxxxxx.com\n```\n除前缀方式外，还可为api单独指定访问域名，如 api.aaaxxxccc.com方式访问接口。\n**API_PREFIX与API_DOMAIN不可同时指定，二者选其一。**\n```bash\nAPI_VERSION=v1 //指定默认访问的版本，未指定Accept版本号时访问此版本\nAPI_DEBUG=true //debug开关\nAPI_STRICT=false //严格模式需要客户端发送 Accept 头，默认false\n```\n* 测试效果\n找到路由目录下的 routes/api.php 文件，laravel默认已经生成了一个路由\n```bash\nroute::middleware('auth:api')->get('/user', function (Request $request) {\n    return $request->user();\n});\n```\n将其修改成DingoApi方式\n\n```bash\n$api = app('Dingo\\Api\\Routing\\Router');\n\n$api->version('v1', function($api) {\n    $api->get('version', function() {\n        return response('kent v1');\n    });\n});\n\n$api->version('v2', function($api) {\n    $api->get('version', function() {\n        return response('kent v2');\n    });\n});\n```\n\n","tags":["Laravel"]},{"title":"使用 Supervisor 管理 Laravel 队列进程","url":"/2019/12/27/使用-Supervisor-管理-Laravel-队列进程/","content":"* 下载Supervisor\n```bash\nyum install -y supervisor\n```\n* Supervisor 的配置\n运行这个命令可以生成一个默认的配置文件：\n```bash\necho_supervisord_conf > /etc/supervisord.conf\n```\n生成成功后，打开编辑这个文件，把最后的 include 块的注释打开，并修改如下：\n```bash\n[include]\nfiles = /etc/supervisor/*.conf\n```\n新增的 Supervisor 配置文件放在 /etc/supervisor 目录下，并且以 conf 结尾。\n这时我们使用新的配置文件来启动 Supervisor：\n```bash\n╰$ supervisord -c /Users/shiyuxiang/develop/config/supervisord.conf\n```\n如果提示已经有进程在运行，那么先 kill 掉它。\n* 使用 Supervisor 管理 Laravel 队列进程\n我们使用 Laravel 队列，会用到 php artisan queue:work 命令，让它监听队列，我们可以通过 nohup 方式让它在后台运行，但是进程如果意外中断是不会自动重启的，所以使用 Supervisor 来监控进程是个很好的方式。\n首先在 /etc/supervisor 目录下新增一个 Supervisor 的配置文件，如下：\n```bash\n[program:laravel-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=php /home/develop/web/sor-cms/artisan queue:work --sleep=3 --tries=3\nautostart=true\nautorestart=true\nuser=vagrant\nnumprocs=8\nredirect_stderr=true\nstdout_logfile=/var/log/supervisor/laravel-queue.log\n```\n这里 user 填写网站运行进程的用户，如 vagrant，numprocs 表示启动多少个进程来监听 Laravel 队列。\n一切就绪后，我们使用如下命令就可以启动队列进程的监听了：\n```bash\n╰$ supervisorctl -c /Users/shiyuxiang/develop/config/supervisord.conf\n```\n这里 user 填写网站运行进程的用户，如 vagrant，numprocs 表示启动多少个进程来监听 Laravel 队列。\n一切就绪后，我们使用如下命令就可以启动队列进程的监听了：\n\n```bash\nsudo supervisorctl reread\n\nsudo supervisorctl update\n\nsudo supervisorctl start laravel-worker:*\n```","tags":["Laravel"]},{"title":" laravel 删除字段","url":"/2019/12/27/laravel-删除字段/","content":"* 使用命令安装doctrine/dbal\n```bash\ncomposer require doctrine/dbal\n````","tags":["Laravel"]},{"title":"快速安装laravel框架的IDE提示工具","url":"/2019/12/27/快速安装laravel框架的IDE提示工具/","content":"* Require this package with composer using the following command:\n```bash\ncomposer require --dev barryvdh/laravel-ide-helper\n```\n* After updating composer, add the service provider to the providers array in config/app.php\n```bash\nBarryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class,\n```\n* In Laravel, instead of adding the service provider in the config/app.php file, you can add the following code to your app/Providers/AppServiceProvider.php file, within the register() method:\n```bash\npublic function register()\n{\n    if ($this->app->environment() !== 'production') {\n        $this->app->register(\\Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class);\n    }\n    // ...\n}\n```\n* You can configure your composer.json to do this after each commit:\n```bash\n\"scripts\":{\n    \"post-update-cmd\": [\n        \"Illuminate\\\\Foundation\\\\ComposerScripts::postUpdate\",\n        \"@php artisan ide-helper:generate\",\n        \"@php artisan ide-helper:meta\"\n    ]\n},\n```\n* You can also publish the config file to change implementations (ie. interface to specific class) or set defaults for —helpers or —sublime.\n```bash\nphp artisan vendor:publish --provider=\"Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider\" --tag=config\n```\n* You can now re-generate the docs yourself (for future updates)\n```bash\nphp artisan ide-helper:generate\n```\n","tags":["Laravel"]},{"title":"laravel 多模块开发","url":"/2019/12/27/larvel-多模块开发/","content":"* 用composer命令下载并安装扩展包包\n```bash\ncomposer require nwidart/laravel-modules\n```\n* 生成配置文件\n```bash\nphp artisan vendor:publish --provider=\"Nwidart\\Modules\\LaravelModulesServiceProvider\"\n```\n* 用artisan命令创建\n```bash\nphp artisan module:make Name\n```\n* 加载模块\n\n```bash\n{\n          \"autoload\": {\n            \"psr-4\": {\n              \"App\\\\\": \"app/\",\n              \"Modules\\\\\": \"Modules/\"\n            }\n          }\n        }\n\n```\n* 修改后执行composer命令使之生效。\n```bash\ncomposer dump-autoload\n```","tags":["Laravel"]},{"title":"安装laravel权限包","url":"/2019/12/27/安装laravel权限包/","content":"* 安装laravel权限包\n```bash\ncomposer require spatie/laravel-permission\n```\n* 你可以使用以下命令发布 migration\n```bash\nphp artisan vendor:publish --provider=\"Spatie\\Permission\\PermissionServiceProvider\" --tag=\"migrations\"\n```\n* migration 发布后，您可以通过运行以下命令来创建角色和权限表：\n```bash\nphp artisan migrate\n```\n* 你可以运行以下命令生成配置文件：\n```bash\nphp artisan vendor:publish --provider=\"Spatie\\Permission\\PermissionServiceProvider\" --tag=\"config\"\n```\n","tags":["Laravel"]},{"title":"搭建sor-cms系统","url":"/2019/12/27/搭建sor-cms系统/","content":"* 下载资源包\n```bash\n╰$ composer create-project --prefer-dist laravel/laravel sor-cms \"5.8.*\"\n```\n* 测试测试方法\n```bash\n╰$ vendor/bin/phpunit\n```\n* 将phpunit放到composer中\n```bash\n\"test\":[\n    \"vendor/bin/phpunit\"\n],\n```\n* 通过composer测试测试方法\n```bash\n╰$ composer test\n```\n* 配置数据库\n```php\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=OaoCms\nDB_USERNAME=root\nDB_PASSWORD=1234567890\n```\n* 生成认证用的路由和视图\n```bash\nphp artisan make:auth\n```\n* 数据库迁移\n```bash\nphp artisan migrate\n```\n* 创建后台用户\n```bash\nphp artisan tinker\n```\n\n[image:8B5CBF6C-641E-4179-A257-BA36BB8BB13B-7146-00016E08E50D26BF/587776FD-B93C-4490-B15E-4BEE78AD7616.png]\n* 创建后台控制器\n```bash\n╰$ php artisan make:controller Admin/PublicController\n```\n* 集成adminlte后台框架\n```bash\ncomposer require \"almasaeed2010/adminlte=~3.0\"\n```","tags":["Laravel"]},{"title":"redis入门","url":"/2019/11/20/redis入门/","content":"## Redis\n### Redis介绍\n---\n#### Nosql 基本概念\n为了解决高并发、高可用、高可扩展，大数据存储等一系列问题而产生的数据库解决方案，就是NoSql。\nNoSql，叫非关系型数据库，它的全名Not only sql。它不能替代关系型数据库，只能作为关系型数据库的一个良好补充。\n#### Nosql 分类\n* 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化\n* 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限\n* 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法\n*  图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。\n\n#### Redis 基本概念\nRedis是使用c语言开发的一个高性能键值数据库。Redis可以通过一些键值类型来存储数据。 键值类型： String字符类型 map散列类型 list列表类型 set集合类型 sortedset有序集合类型\n\n#### 发展历史\n2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo便 对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。 不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。\nSalvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。\nVMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。\n\n#### 应用场景\n缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用） 分布式集群架构中的session分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306等等） 应用排行榜。 网站访问统计。 数据过期处理（可以精确到毫秒）\n\n### Redis 安装\n---\n#### 下载\n官网地址：http://redis.io/ 下载地址：http://download.redis.io/releases/redis-3.0.0.tar.gz\n\n#### 安装\n```bash\n#sftp 上传安装包到linux\n#解压\ntar -zxvf redis.3.0.0.tar.gz\n#安装c语言环境\nsudo apt-get install gcc-c++\n#编译\ncd redis-3.0.0\nmake\n#安装\nmake install PREFIX = /usr/local/redis\n# 查看\ncd /usr/local/redis\nls\n```\n\n### redis 启动\n#### 前端启动\n* 前端启动命令 ./redis-server\n* 前端启动的关闭 强制关闭 ctrl+c 正常关闭 ./redis-cli shutdown\n\n**tips:**一旦客户端关闭，则redis服务也会停掉\n\n#### 后端启动\n* 将 redis 源码包中的 redis.conf 文件拷贝至 bin 目录下 cp /root/redis-3.0.0/redis.conf\n* 修改 redis.conf 文件，将 daemonize 改为 yes vim redis.conf\n* 使用后端命令启动 redis ./redis-server redis.conf\n* 查看是否启动成功 ps -aux | grep redis\n* 关闭后端启动的方式 强制关闭： kill -9 进程号 正常关闭：./redis-cli shutdown\n\n### Redis 客户端\n---\n#### 自带客户端\n* 启动 ./redis-cli -h 127.0.0.1 -p 6379 -h 指定访问 redis 服务器的 ip 地址 -p 指定访问的 redis 服务器的 port 端口 还可以写成 ./redis-cli 使用默认配置，默认ip 127.0.0.1,默认端口 6379\n* 关闭 ctrl + c 127.0.0.1:6379>quit\n\n#### 图形界面客户端\nredis-desktop-manager 打开如下：\n[image:B3C0C376-80DB-4E5F-B28B-CEB593F0A8E2-1233-0000817AF9C5FAA3/164a814fb76b84fb.png]\n[image:1DC6AAC5-4431-4BA1-BDA8-DC0E34D4B420-1233-0000817E62C0D5C0/164a814fb77dd501.png]\n选择数据库方式： select 加上数据库的下标，就可以选择指定的数据库使用，下标从0开始。\n```bash\n127.0.0.1:6379> select 15\nOK\n127.0.0.1:6379[15]>\n```\n### jedis 客户端\n#### 介绍\nRedis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。\n在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。\nJedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis\n#### 工程搭建\n* 添加 jar commons-pool2-2.3.jar jedis-2.7.0.jar\n\n#### 单例连接redis\n[image:6EBCB229-93DC-4726-8B90-415AA0308CCD-1233-00008260493C9B9B/164a814fb78554a7.jpg]\n#### 使用连接池连接 redis\n[image:F411BD3E-EA04-463A-97AB-8672EDA6BA6D-1233-000082686ADE3522/164a814fb7d9bcaf.jpg]\n#### Spring 整合 jedisPool\n添加 spring 的 jar 包 配置 spring 配置文件 applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n\n<!-- 连接池配置 --> \n<bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"> \n<!-- 最大连接数 --> \n<property name=\"maxTotal\" value=\"30\" /> \n<!-- 最大空闲连接数 --> \n<property name=\"maxIdle\" value=\"10\" /> \n<!-- 每次释放连接的最大数目 --> \n<property name=\"numTestsPerEvictionRun\" value=\"1024\" /> \n<!-- 释放连接的扫描间隔（毫秒） --> \n<property name=\"timeBetweenEvictionRunsMillis\" value=\"30000\" /> \n<!-- 连接最小空闲时间 --> \n<property name=\"minEvictableIdleTimeMillis\" value=\"1800000\" /> <!-- 连接空闲多久后释放, 当空闲时间>该值 且 空闲连接>最大空闲连接数 时直接释放 --> \n<property name=\"softMinEvictableIdleTimeMillis\" value=\"10000\" /> \n<!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --> <property name=\"maxWaitMillis\" value=\"1500\" /> \n<!-- 在获取连接的时候检查有效性, 默认false --> \n<property name=\"testOnBorrow\" value=\"false\" /> \n<!-- 在空闲时检查有效性, 默认false --> \n<property name=\"testWhileIdle\" value=\"true\" /> \n<!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --> <property name=\"blockWhenExhausted\" value=\"false\" /> </bean> <!-- redis单机 通过连接池 --> \n<bean id=\"jedisPool\" class=\"redis.clients.jedis.JedisPool\" destroy-method=\"close\"> <constructor-arg name=\"poolConfig\" ref=\"jedisPoolConfig\" /> <constructor-arg name=\"host\" value=\"192.168.242.130\" /> <constructor-arg name=\"port\" value=\"6379\" /> </bean> </beans>\n```\n\n测试代码\n```java\n@Test \npublic void testJedisPool() { \nJedisPool pool = (JedisPool)applicationContext.getBean(\"jedisPool\"); \nJedis jedis = null; \ntry { \njedis = pool.getResource(); \njedis.set(\"name\", \"lisi\"); \nString name = jedis.get(\"name\"); \nSystem.out.println(name); \n} catch (Exception ex) { \nex.printStackTrace(); \n} finally { \nif (jedis != null) {\n // 关闭连接 \njedis.close(); \n} \n} \n}\n```\n\n### 数据类型\n---\n#### String 类型\n赋值 set key value\n```bash\n127.0.0.1:6379> set test 123\nOK\n```\n取值 get key\n```bash\n127.0.0.1:6379> get test\n\"123\"\n```\n取值并赋值 get set key value\n```bash\n127.0.0.1:6379> getset test 321\n\"123\"\n127.0.0.1:6379> get test\n\"321\"\n```\n设置获取多个键值 mset key value [key value…] mget key [key…]\n```bash\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3\nOK\n127.0.0.1:6379> mget k1 k2\n1) \"v1\"\n2) \"v2\"\n```\n删除 del key\n```bash\n127.0.0.1:6379> del test\n(integer) 1\n```\n数值增减\n* 递增数字 当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 语法：incr key\n```bash\n127.0.0.1:6379> set num 1 OK 127.0.0.1:6379> incr num (integer) 2 127.0.0.1:6379> incr num (integer) 3 127.0.0.1:6379> incr num (integer) 4\n```\n* 增加指定的整数 incrby key increment\n\n```bash\n127.0.0.1:6379> incrby num 2\n(integer) 8\n127.0.0.1:6379> incrby num 2\n(integer) 10\n```\n* 递减数值 decr key\n```bash\n127.0.0.1:6379> decr num\n(integer) 9\n127.0.0.1:6379> decr num\n(integer) 8\n```\n* 减少指定的数值 decryby key decrement\n```bash\n127.0.0.1:6379> decrby num 2\n(integer) 6\n127.0.0.1:6379> decrby num 2\n(integer) 4\n```\n向尾部追加值 APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 语法：append key value\n\n```bash\n127.0.0.1:6379> set str hello\nOK\n127.0.0.1:6379> append str \"world\"\n(integer) 10\n127.0.0.1:6379> get str\n\"helloworld\"\n```\n获取字符串长度 STRLEN命令返回键值的长度，如果键不存在则返回0。 语法：strlen key\n```bash\n127.0.0.1:6379> strlen str\n(integer) 10\n```\n\n应用\n* 自增主键 商品编号、订单号采用 string 的递增数字特性生成\n### Hash 散列类型\n#### 使用 string 的问题\n假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 保存、更新：User对象 json(string) redis\n如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。\n\n#### 介绍\nHash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下：\n[image:4AE26D63-F3BF-450E-8D10-13545CB7838E-1233-000083499BF8DDEB/164a814fb7c5cdaf.png]\n#### 命令\n赋值 HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。\n* 一次只设置一个字段值 语法：hset key field value\n```bash\n127.0.0.1:6379> hset user username zhangsan\n(integer) 1\n```\n* 一次设置多个字段值 语法：hmset key field value [field value…]\n```bash\n127.0.0.1:6379> hmset user age 20 username lisi\nOK\n```\n* 当字段不存在时赋值，类似hset,区别在于如果字段存在，该命令不执行任何操作。 语法：hsetnx key field value\n```bash\n127.0.0.1:6379> hsetnx user age 30\n(integer) 0\n```\n\n取值\n* 一次获取一个字段值 语法：hget key field\n```bash\n127.0.0.1:6379> hget user username\n\"lisi\"\n```\n* 一次可以获取多个字段值 语法：hmget key field [field…]\n```bash\n127.0.0.1:6379> hmget user age username\n1) \"20\"\n2) \"lisi\"\n```\n* 获取所有字段值 语法：hgetall key\n```bash\n127.0.0.1:6379> hgetall user\n1) \"username\"\n2) \"lisi\"\n3) \"age\"\n4) \"20\"\n```\n\n删除字段 可以删除一个或多个字段，返回值是被删除的字段的个数。 语法：hdel key field [field…]\n```bash\n127.0.0.1:6379> hdel user age\n(integer) 1\n127.0.0.1:6379> hdel user age username\n(integer) 1\n```\n\n增加数字 语法：hincrby key field increment\n```bash\n127.0.0.1:6379> hincrby user age 2\n(integer) 2\n```\n\n判断字段是否存在 语法：hexists key field\n```bash\n127.0.0.1:6379> hexists user age\n(integer) 1\n```\n\n只获取字段名或字段值 语法： hkeys key hvals key\n```bash\n127.0.0.1:6379> hkeys user\n1) \"age\"\n```\n\n获取字段数量 语法：hlen key\n```bash\n127.0.0.1:6379> hlen user\n(integer) 1\n```\n\n应用 存储商品信息\n```bash\n127.0.0.1:6379> hlen user\n(integer) 1\n```\n\n获取商品信息\n```bash\n127.0.0.1:6379> hgetall items:1001\n1) \"id\"\n2) \"3\"\n3) \"name\"\n4) \"apple\"\n5) \"price\"\n6) \"5.00\"\n```\n\n### List 类型\n#### ArrayList 和 LinkedList 的区别\n\nArraylist是使用数组来存储数据，特点：查询快、增删慢\n\nLinkedlist是使用双向链表存储数据，特点：增删快、查询慢，但是查询链表两端的数据也很快。\n\nRedis的list是采用来链表来存储的，所以对于redis的list数据类型的操作，是操作list的两端数据来操作的。\n\n#### 命令\n向列表两端增加元素\n* 向列表左边增加元素 语法：lpush key value [value…]\n```bash\n127.0.0.1:6379> lpush list:1 1 2 3\n(integer) 3\n```\n* 向列表右边增加元素 语法：rpush key value [value…]\n```bash\n127.0.0.1:6379> rpush list:1 4 5 6\n(integer) 6\n```\n\n查看列表 LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。\n\n语法：lrange key start stop\n\n```bash\n127.0.0.1:6379> lrange list:1 0 2 \n1) \"3\" \n2) \"2\" \n3) \"1\" \n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"3\" \n2) \"2\" \n3) \"1\" \n4) \"4\" \n5) \"5\" \n6) \"6\" \n```\n\n从列表两端弹出元素 LPOP命令从列表左边弹出一个元素，会分两步完成：\n* 第一步是将列表左边的元素从列表中移除\n* 第二步是返回被移除的元素值。 语法： lpop key rpop key\n```bash\n127.0.0.1:6379> lpop list:1\n\"3\"\n127.0.0.1:6379> rpop list:1\n\"6\"\n```\n\n删除列表中指定的值 LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同：\n* 当count>0时， LREM会从列表左边开始删除。\n* 当count<0时， LREM会从列表后边开始删除。\n* 当count=0时， LREM删除所有值为value的元素。\n\n语法：lrem key count value\n\n获得/设置指定索引的元素值\n* 获得指定索引的元素值 语法：lindex key index\n```bash\n127.0.0.1:6379> lindex list:1 2\n\"4\"\n```\n\n* 设置指定索引的元素值 语法：lset key index value\n\n```bash\n127.0.0.1:6379> lset list:1 2 2\nOK\n```\n\n只保留列表指定片段 指定范围和 lrange 一致 语法：ltrim key start stop\n\n```bash\n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"2\" \n2) \"1\" \n3) \"2\" \n4) \"5\" \n127.0.0.1:6379> ltrim list:1 0 2 \nOK \n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"2\" \n2) \"1\" \n3) \"2\"\n```\n\n向列表中插入元素 该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 语法：linsert key before | after pivot value\n\n```bash\n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"2\" \n2) \"1\" \n3) \"2\" \n127.0.0.1:6379> linsert list:1 after 1 9 \n(integer) 4 \n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"2\" \n2) \"1\" \n3) \"9\" \n4) \"2\"\n```\n\n将元素从一个列表转移到另一个列表 语法：rpoplpush source destination\n\n```bash\n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"2\" \n2) \"1\" \n3) \"9\" \n4) \"2\" \n127.0.0.1:6379> rpoplpush list:1 newlist \n\"2\" \n127.0.0.1:6379> lrange newlist 0 -1 \n1) \"2\" \n127.0.0.1:6379> lrange list:1 0 -1 \n1) \"2\" \n2) \"1\" \n3) \"9\"\n```\n\n应用 在Redis中创建商品评论列表 用户发布商品评论，将评论信息转成json存储到list中。 用户在页面查询评论列表，从redis中取出json数据展示到页面。\n\n定义商品评论列表key： 商品编号为1001的商品评论key【items: comment:1001】\n\n### Set 类型\n\n> 集合类型：无序、不可重复 列表类型：有序、可重复\n\n#### 命令\n\n增加/删除元素 语法：sadd key member [member…]\n\n```bash\n127.0.0.1:6379> sadd set a b c\n(integer) 3\n127.0.0.1:6379> sadd set a\n(integer) 0\n```\n\n语法：srem key member [member…]\n\n```bash\n127.0.0.1:6379> srem set c\n(integer) 1\n```\n\n获得集合中的所有元素 语法：smembers key\n\n```bash\n127.0.0.1:6379> smembers set\n1) \"b\"\n2) \"a\"\n```\n\n判断元素是否在集合中 语法：sismember key member\n\n```bash\n127.0.0.1:6379> sismember set a\n(integer) 1\n127.0.0.1:6379> sismember set h\n(integer) 0\n```\n\n### 运算命令\n\n集合的差集运算 A-B 属于 A 并且 不属于 B 的元素构成的集合\n\n[image:5C7853BC-8199-4101-8B1C-BA929DC4734E-1233-0000848259EFEA09/164a814fb7f44674.jpg]\n\n语法：sdiff key [key…]\n```bash\n127.0.0.1:6379> sadd setA 1 2 3 \n(integer) 3 \n127.0.0.1:6379> sadd setB 2 3 4 \n(integer) 3 \n127.0.0.1:6379> sdiff setA setB \n1) \"1\" \n127.0.0.1:6379> sdiff setB setA \n1) \"4\"\n```\n\n集合的交集运算 属于A且属于B的元素构成的集合\n\n[image:0F29ED34-4FB3-4C28-92FD-80863F434A77-1233-0000849B377A2E72/164a814fdd992d6b.jpg]\n语法：sinter key [key…]\n```bash\n127.0.0.1:6379> sinter setA setB\n1) \"2\"\n2) \"3\"\n```\n\n集合的并集运算 属于 A 或者 属于 B 的元素构成的集合\n\n[image:201C2779-14BD-4812-B8CC-CEDF0DBA59E5-1233-000084A65168840C/164a814fdf3b75b5.jpg]\n\n语法：sunion key [key…]\n\n```bash\n127.0.0.1:6379> sunion setA setB\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"4\"\n```\n\n获得集合中元素的个数 语法：scard key\n\n```bash\n127.0.0.1:6379> smembers setA\n1) \"1\"\n2) \"2\"\n3) \"3\"\n127.0.0.1:6379> scard setA\n(integer) 3\n```\n\n从集合中弹出一个元素 注意:由于集合是无序的，所有spop命令会从集合中随机选择一个元素弹出。 语法：spop key\n\n```bash\n127.0.0.1:6379> spop setA\n\"2\"\n```\n\n### Sortedset 类型\n\nSortedset 又叫 zset Sortedset 是有序集合，可排序的，但是唯一。 Sortedset 和 set 的不同之处，会给 set 中元素添加一个分数，然后通过这个分数进行排序。\n\n#### 命令\n#### 增加元素\n\n向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 语法：zadd key score member [score member…]\n\n```bash\n127.0.0.1:6379> zadd scoreboard 80 zhangsan 89 lisi 94 wangwu\n(integer) 3\n127.0.0.1:6379> zadd scoreboard 97 lisi\n(integer) 0\n```\n\n#### 获取元素分数\n\n语法：zscore key member\n\n```bash\n127.0.0.1:6379> zscore scoreboard lisi\n\"97\"\n```\n\n#### 获得排名在某个范围的元素列表\n\n获得排名在某个范围的元素列表\n* 按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：zrange key start stop [withscores]\n```bash\n127.0.0.1:6379> zrange scoreboard 0 2\n1) \"zhangsan\"\n2) \"wangwu\"\n```\n* 按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：zrevrange key start stop [withscores]\n```bash\n127.0.0.1:6379> zrevrange scoreboard 0 2\n1) \"wangwu\"\n2) \"zhangsan\"\n```\n\n如果需要获得元素的分数可以在命令末尾加上 withscores 参数 ··· 127.0.0.1:6379> zrevrange scoreboard 0 2 withscores\n```bash\n1. \"wangwu\"\n2. \"94\"\n3. \"zhangsan\"\n4. \"80\" ···\n```\n\n#### 获取元素的排名\n* 从小到大 语法：zrank key member\n```bash\n127.0.0.1:6379> zrank scoreboard zhangsan\n(integer) 0\n```\n\n* 从大到小 语法：zrevrank key member\n```bash\n127.0.0.1:6379> zrevrank scoreboard zhangsan\n(integer) 1\n```\n\n#### 获得指定分数范围的元素\n \n语法：zrangebyscore key min max [withscores] [limit offset count]\n\n```bash\n127.0.0.1:6379> ZRANGEBYSCORE scoreboard 90 97 WITHSCORES \n1) \"wangwu\" \n2) \"94\" \n3) \"lisi\" \n4) \"97\" \n127.0.0.1:6379> ZRANGEBYSCORE scoreboard 70 100 limit 1 2 \n1) \"wangwu\" \n2) \"lisi\"\n```\n\n#### 增加某个元素的分数\n\n返回值是更改后的分数 语法：zincrby key increment member\n\n```bash\n127.0.0.1:6379> ZINCRBY scoreboard 4 lisi \n\"101“\n```\n\n#### 获得集合中元素的数量\n\n语法：zcard key\n```bash\n127.0.0.1:6379> zcard scoreboard\n(integer) 3\n```\n\n#### 获得指定分数范围内的元素个数\n\n语法：zcount key min max\n\n```bash\n127.0.0.1:6379> zcount scoreboard 80 90\n(integer) 1\n```\n\n#### 按照排名范围删除元素\n\n语法：zremrangebyrank key start stop\n\n```bash\n127.0.0.1:6379> zremrangebyrank scoreboard 0 1\n(integer) 2\n127.0.0.1:6379> zrange scoreboard 0 -1\n1) \"wangwu\"\n```\n\n#### 按照分数范围删除元素\n\n语法：zremrangebyscore key min max\n\n```bash\n127.0.0.1:6379> zadd scoreboard 84 zhangsan    \n(integer) 1\n127.0.0.1:6379> ZREMRANGEBYSCORE scoreboard 80 100\n(integer) 1\n```\n\n### 应用\n#### 商品销售排行榜\n\n需求：根据商品销售量对商品进行排行显示 思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。\n\n写入商品销售量：\n* 商品编号1001的销量是9，商品编号1002的销量是10 192.168.101.3:7007> ZADD items:sellsort 9 1001 10 1002\n* 商品编号1001的销量加1 192.168.101.3:7001> ZINCRBY items:sellsort 1 1001\n* 商品销量前10名： 192.168.101.3:7001> ZRANGE items:sellsort 0 9 withscores\n\n## keys 命令\n---\n### 常用命令\n* keys 返回满足给定pattern 的所有key redis 127.0.0.1:6379> keys mylist*\n\t1. “mylist”\n\t2. “mylist5”\n\t3. “mylist6”\n\t4. “mylist7”\n\t5. “mylist8”\n* exists 确认一个key 是否存在 示例：从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的 redis 127.0.0.1:6379> exists HongWan (integer) 0 redis 127.0.0.1:6379> exists age (integer) 1 redis 127.0.0.1:6379>\n* del 删除一个key redis 127.0.0.1:6379> del age (integer) 1 redis 127.0.0.1:6379> exists age (integer) 0\n* rename 重命名key 示例：age 成功的被我们改名为age_new 了 redis 127.0.0.1:6379[1]> keys *\n1. “age” redis 127.0.0.1:6379[1]> rename age age_new OK redis 127.0.0.1:6379[1]> keys *\n2. “age_new” redis 127.0.0.1:6379[1]>\n* * type 返回值的类型 示例：这个方法可以非常简单的判断出值的类型 redis 127.0.0.1:6379> type addr string redis 127.0.0.1:6379> type myzset2 zset redis 127.0.0.1:6379> type mylist list redis 127.0.0.1:6379>\n\n### 设置 key 的生存时间\nRedis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。\n\n|         |       |\n|  EXPIRE key seconds  | 设置key的生存时间（单位：秒）key在多少秒后会自动删除|\n| TTL key  |查看key剩余的生存时间 |\n| PERSIST key |清除生存时间 |\n| PEXPIRE key milliseconds |生存时间设置单位为：毫秒 |\n\n例子：\n```bash\n192.168.101.3:7002> set test 1 设置test的值为1 OK 192.168.101.3:7002> get test 获取test的值 \"1\" 192.168.101.3:7002> EXPIRE test 5 设置test的生存时间为5秒 (integer) 1 192.168.101.3:7002> TTL test 查看test的生于生成时间还有1秒删除 (integer) 1 192.168.101.3:7002> TTL test (integer) -2 192.168.101.3:7002> get test 获取test的值，已经删除 (nil) \n```\n\n### Redis 持久化方案\n#### Rdb 方式\n\nRedis 默认的方式，redis 通过快照方式将数据持久化到磁盘中。\n\n#### 设置持久化快照的条件\n\n在 redis.conf 中修改持久化快照的条件：\n[image:66558BDA-3BD8-4FFF-BF8E-87DB340F8431-1233-0000869386BE2559/164a814fe0a1ada1.png]\n\n#### 持久化文件的存储目录\n\n在 redis.conf 中可以指定持久化文件的存储目录\n\n[image:E439E41B-3456-4B9C-8C17-A6447DA5CE38-1233-0000869DBC934801/164a814fe1863fc4.png]\n\n#### Rdb 的问题\n\n一旦redis非法关闭，那么会丢失最后一次持久化之后的数据。\n\n如果数据不重要，则不必要关心。 如果数据不能允许丢失，那么要使用 aof 方式。\n\n#### Aof 方式\n\nRedis 默认是不使用该方式持久化的。Aof 方式的持久化，是操作一次 redis 数据库，则将操作的记录存储到 aof 持久化文件中。\n* 第一步：开启 aof 方式持久化方案。 将redis.conf中的appendonly改为yes，即开启aof方式的持久化方案。\n [image:CD09A3F6-DA96-455F-ACCA-AB0ADEDEEFB4-1233-000086B200819B9C/164a814fe9e43230.png]\n* Aof文件存储的目录和rdb方式的一样。 Aof文件存储的名称\n[image:277139A0-9EF7-4F9F-B6B7-0859CB4C073E-1233-000086B64AE551C2/164a815002bc38e1.png]\n\n在使用aof和rdb方式时，如果redis重启，则数据从aof文件加载。\n\n## Redis 的主从复制\n---\n### 什么是主从复制\n\n持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图：\n[image:F94ACC77-2259-4E5C-A2FD-AB397C7C7330-1233-000086CCF9808B1B/164a81500462a9fe.png]\n\n说明：\n* 主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。\n* 主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。\n* 只有一个主redis，可以有多个从redis。\n* 主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求\n* 一个redis可以即是主又是从，如下图：\n[image:A66B668D-3E02-4625-B8D0-4E8E8460BB6E-1233-000086EB59D21777/164a81500a27a479.png]\n\n### 主从复制设置\n#### 主机配置\n\n无需配置\n\n#### 从机配置\n* 第一步：复制出一个从机cp bin/ bin2 -r\n* 第二步：修改从机的 redis.conf 语法：slaveof masterip masterport slaveof 192.168.242.137 6379\n[image:9030845F-B001-4C65-BD4F-D947802C2ABD-1233-000087073B20920C/164a81500eb3446c.png]\n* 第三步：修改从机的 port 地址为 6380\n[image:D82886AF-109A-4E01-80E9-5CBAB8606197-1233-0000870CCEFDC2C5/164a815020992d63.png]\n* 第四步：清除从机的持久化文件 rm -rf appendonly.aof dump.rdb\n* 第五步：启动从机 ./redis-server redis.conf\n* 第六步：启动6380的客户端 ./redis-cli -p 6380\n\n> 注意：主机一旦发生增删改操作，那么从机会将数据同步到从机中 从机不能执行写操作\n\n### Redis 集群\n---\n#### redis-cluster 架构图\n[image:2C1166C7-BACE-499D-B965-4F8CE96AB622-1233-000087322EBBF9DC/164a8150227f25b1.jpg]\n\n架构细节: (1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽. (2)节点的fail是通过集群中超过半数的节点检测失效时才生效. (3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可 (4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点.\n[image:D18DF8F6-E204-42C6-B705-34B0BB33E4EB-1233-0000873C2716DFD6/164a8150159e9a2c.png]\n\n#### redis-cluster 投票 容错\n[image:D82F7E57-1088-4D56-9DDB-6B619AA479D6-1233-0000874364AF2D3D/164a81502f173d74.png]\n\n(1)集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超过(cluster-node-timeout),认为该master节点挂掉. (2):什么时候整个集群不可用(cluster_state:fail)?\n* 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。\n* 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。\n\n#### 安装 Ruby\n集群管理工具（redis-trib.rb)是使用 ruby 脚本语言编写的。\n* 安装 ruby\n\n```bash\nsudo apt-get install ruby\n```\n\n* 上传 redis-3.0.0.gem 到 linux\n* 安装 ruby 和 redis 接口 gem install redis-3.0.0.gem\n* 将 redis-3.0.0 包下 src 目录中的以下文件拷贝到 redis/redis-cluster/\n\n```bash\ncd /usr/local/redis/\nmkdir redis-cluster\ncd /root/redis-3.0.0/src/\ncp redis-trib.rb /usr/local/redis/redis-cluster\n```\n\n#### 搭建集群\n\n搭建集群最少需要 3 台主机，如果每台主机再配置一台从机的话，则最少需要6台机器。 端口设计：7001-7006\n\n1. 复制出一个7001机器cp bin ./redis-cluster/7001 -r\n2. 如果存在持久化文件，则删除rm -rf appendonly.aof dump.rdb\n3. 设置集群参数，修改redis.conf\n[image:91D7C4C7-E9D0-4622-9373-7A55909A7AE8-1233-0000878CC6455B59/164a81503955b32e.png]\n4. 修改端口\n[image:A5E30DFF-017F-4002-A2AA-CBF616CDDE04-1233-0000879B21515153/164a815042962114.png]\n5. 复制出7002-7006机器\n```bash\ncp 7001/ 7002-r\ncp 7001/ 7003-r\ncp 7001/ 7004-r\ncp 7001/ 7005-r\ncp 7001/ 7006-r\n```\n6. 修改7002-7006机器端口\n7. 创建文件 start-all.sh\n```bash\ncd 7001 \n./redis-server redis.conf \ncd .. \ncd 7002 \n./redis-server redis.conf \ncd .. \ncd 7003 \n./redis-server redis.conf \ncd .. \ncd 7004 \n./redis-server redis.conf \ncd .. \ncd 7005 \n./redis-server redis.conf \ncd .. \ncd 7006 \n./redis-server redis.conf \ncd .. \n```\n8. 修改文件权限\n```bash\nchmod u+x start-all.sh\n```\n9. 执行文件，启动六台机器\n```bash\n./start-all.sh\n```\n10. 创建集群 ./redis-trib.rb create —replicas 1 192.168.126.128:7001 192.168.126.128:7002 192.168.126.128:7003 192.168.126.128:7004 192.168.126.128:7005 192.168.126.128:7006\n\n#### 连接集群\nroot@ubuntu:/usr/local/redis/redis-cluster/7001# ./redis-cli -p 7001 -c\n\n-c 指定集群连接\n\n#### 查看集群信息\n* 查看集群信息\n```bash\n192.168.126.128:7002> cluster info \ncluster_state:ok \ncluster_slots_assigned:16384 \ncluster_slots_ok:16384 \ncluster_slots_pfail:0 \ncluster_slots_fail:0 \ncluster_known_nodes:6 \ncluster_size:3 \ncluster_current_epoch:6 \ncluster_my_epoch:2 \ncluster_stats_messages_sent:260 cluster_stats_messages_received:260\n```\n* 查看集群节点\n```bash\n192.168.126.128:7002> cluster nodes\n3a15e73dacb512745156535ae7f959acf65ae12e 192.168.126.128:7005 slave 23e173cdc0b7673dc28cae70efaabbc41308bfdc 0 1531452321139 5 connected \n2a58a53a5b10f7bd91af04128a6ed439d534c0ee 192.168.126.128:7001 master - 0 1531452322145 1 connected 0-5460\nd0808388485dd08f1a2ecdfe3d2b213742d0050d 192.168.126.128:7004 slave 2a58a53a5b10f7bd91af04128a6ed439d534c0ee 0 1531452318117 4 connected \n23e173cdc0b7673dc28cae70efaabbc41308bfdc 192.168.126.128:7002 myself,master - 0 0 2 connected 5461-10922\n2af2312acc56552f9f73470f90d9a51973fc74d3 192.168.126.128:7006 slave 78faf92cfdbd12e1b27b270fb0798e67017f4d0b 0 1531452320132 6 connected \n78faf92cfdbd12e1b27b270fb0798e67017f4d0b 192.168.126.128:7007 master - 0 1531452319123 3 connected 10923-16383\n```\n\n#### jedis连接集群\n```java\n@Test \npublic void jedisCluster() { \n// 创建jedisCluster \nSet<HostAndPort> nodes = new HashSet<>(); \nnodes.add(new HostAndPort(\"192.168.242.137\", 7001)); nodes.add(new HostAndPort(\"192.168.242.137\", 7002)); nodes.add(new HostAndPort(\"192.168.242.137\", 7003)); nodes.add(new HostAndPort(\"192.168.242.137\", 7004)); nodes.add(new HostAndPort(\"192.168.242.137\", 7005)); nodes.add(new HostAndPort(\"192.168.242.137\", 7006)); nodes.add(new HostAndPort(\"192.168.242.137\", 7007)); JedisCluster cluster = new JedisCluster(nodes); cluster.set(\"s4\", \"444\"); \nString result = cluster.get(\"s4\"); \nSystem.out.println(result); \ncluster.close(); \n}\n```\n\n#### 使用 spring\n\n配置 applicationContext.xml\n\n```xml\n<!-- 连接池配置 --> \n<bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"> \n<!-- 最大连接数 --> \n<property name=\"maxTotal\" value=\"30\" /> \n<!-- 最大空闲连接数 --> \n<property name=\"maxIdle\" value=\"10\" /> \n<!-- 每次释放连接的最大数目 --> \n<property name=\"numTestsPerEvictionRun\" value=\"1024\" /> \n<!-- 释放连接的扫描间隔（毫秒） --> \n<property name=\"timeBetweenEvictionRunsMillis\" value=\"30000\" /> \n<!-- 连接最小空闲时间 --> \n<property name=\"minEvictableIdleTimeMillis\" value=\"1800000\" /> <!-- 连接空闲多久后释放, 当空闲时间>该值 且 空闲连接>最大空闲连接数 时直接释放 --> \n<property name=\"softMinEvictableIdleTimeMillis\" value=\"10000\" /> \n<!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --> <property name=\"maxWaitMillis\" value=\"1500\" /> \n<!-- 在获取连接的时候检查有效性, 默认false -->\n<property name=\"testOnBorrow\" value=\"true\" /> \n<!-- 在空闲时检查有效性, 默认false --> \n<property name=\"testWhileIdle\" value=\"true\" /> \n<!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --> <property name=\"blockWhenExhausted\" value=\"false\" /> \n</bean>\n<!-- redis集群 --> \n<bean id=\"jedisCluster\" class=\"redis.clients.jedis.JedisCluster\"> \n<constructor-arg index=\"0\"> \n<set> \n<bean class=\"redis.clients.jedis.HostAndPort\"> \n<constructor-arg index=\"0\" value=\"192.168.101.3\">\n</constructor-arg> \n<constructor-arg index=\"1\" value=\"7001\">\n</constructor-arg> \n</bean> \n<bean class=\"redis.clients.jedis.HostAndPort\"> \n<constructor-arg index=\"0\" value=\"192.168.101.3\">\n</constructor-arg> \n<constructor-arg index=\"1\" value=\"7002\">\n</constructor-arg> \n</bean> \n<bean class=\"redis.clients.jedis.HostAndPort\"> \n<constructor-arg index=\"0\" value=\"192.168.101.3\">\n</constructor-arg> \n<constructor-arg index=\"1\" value=\"7003\">\n</constructor-arg> \n</bean> \n<bean class=\"redis.clients.jedis.HostAndPort\"> \n<constructor-arg index=\"0\" value=\"192.168.101.3\">\n</constructor-arg> \n<constructor-arg index=\"1\" value=\"7004\">\n</constructor-arg> \n</bean> \n<bean class=\"redis.clients.jedis.HostAndPort\"> \n<constructor-arg index=\"0\" value=\"192.168.101.3\">\n</constructor-arg> \n<constructor-arg index=\"1\" value=\"7005\">\n</constructor-arg> \n</bean> \n<bean class=\"redis.clients.jedis.HostAndPort\"> \n<constructor-arg index=\"0\" value=\"192.168.101.3\">\n</constructor-arg> \n<constructor-arg index=\"1\" value=\"7006\">\n</constructor-arg> \n</bean> \n</set> \n</constructor-arg> \n<constructor-arg index=\"1\" ref=\"jedisPoolConfig\">\n</constructor-arg> \n</bean>\n```\n\n#### 测试代码\n\n```java\nprivate ApplicationContext applicationContext; \n@Before \npublic void init() { \napplicationContext = new ClassPathXmlApplicationContext( \"classpath:applicationContext.xml\"); \n} \n// redis集群 \n@Test \npublic void testJedisCluster() { \nJedisCluster jedisCluster = (JedisCluster) applicationContext .getBean(\"jedisCluster\"); jedisCluster.set(\"name\", \"zhangsan\"); String value = jedisCluster.get(\"name\"); System.out.println(value); \n}\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Redis"]},{"title":"virtualenv安装","url":"/2019/11/20/virtualenv安装/","content":"* 安装\n\n```bash\npip install virtualenv\n\npip install virtualenvwrapper #win环境\n  \nmkvirtualenv DjangoProject    #创建虚拟环境\n\nworkon                       #查看有哪些虚拟环境\n\nworkon DjangoProject      #进入创建的虚拟环境\n\ndeactivate      #退出虚拟环境\n\nactivate        #激活虚拟环境\n```\n","tags":["virtualenv"],"categories":["virtualenv"]},{"title":"python教程","url":"/2019/11/20/python教程/","content":"## 查看 Python 版本\n我们可以在命令窗口(Windows 使用 win+R 调出 cmd 运行框)使用以下命令查看我们使用的 Python 版本：\n```bash\npython -V\n```\n以上命令执行结果如下：\n```bash\nPython 3.7.4\n```\n你也可以进入Python的交互式编程模式，查看版本：\n```bash\nPython 3.7.4 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> \n```\n---\n## 第一个Python3.x程序\n对于大多数程序语言，第一个入门编程代码便是”Hello World！”，以下代码为使用Python输出”Hello World！”：\n\n```python\n#!/usr/bin/python3\nprint(\"Hello, World!\")\n```\n你可以将以上代码保存在 hello.py 文件中并使用 python 命令执行该脚本文件。\n```bash\n$ python3 hello.py\n```\n以上命令输出结果为：\n```bash\nHello, World!\n```\n---\n## Python3简介\nPython 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。\nPython 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。\n\t* *Python 是一种解释型语言：*这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 \n\t* *Python 是交互式语言：*这意味着，您可以在一个 Python 提示符*>>>*后直接执行代码。\n\t* *Python 是面向对象语言:*这意味着Python支持面向对象的风格或代码封装在对象的编程技术。\n\t* *Python 是初学者的语言：*Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\t\n---\n\n## Python 发展历史\nPython 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。\nPython 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。\n像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。\n现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。\nPython 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。\nPython 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的Python 2.6/2.7版本。\nPython 3.0 版本，常被称为 Python 3000，或简称 Py3k。相对于 Python 的早期版本，这是一个较大的升级。\nPython 2.7 被确定为最后一个 Python 2.x 版本，它除了支持 Python 2.x 语法外，还支持部分 Python 3.1 语法。\n---\n## Python 特点\n* *1.易于学习：*Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。\n\n* *2.易于阅读：*Python代码定义的更清晰。\n\n* *3.易于维护：*Python的成功在于它的源代码是相当容易维护的。\n\n* *4.一个广泛的标准库：*Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。\n\n* *5.互动模式：*互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。\n\n* *6.可移植：*基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。\n\n* *7.可扩展：*如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。\n\n* *8.数据库：*Python提供所有主要的商业数据库的接口。\n\n* *9.GUI编程：*Python支持GUI可以创建和移植到许多系统调用。\n\n* *10.可嵌入:*你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。\n\n## Python 应用\n* Youtube - 视频社交网站\n* Reddit - 社交分享网站\n* Dropbox - 文件分享服务\n* 豆瓣网 - 图书、唱片、电影等文化产品的资料数据库网站\n* 知乎 - 一个问答网站\n* 果壳 - 一个泛科技主题网站\n* Bottle - Python微Web框架\n* EVE - 网络游戏EVE大量使用Python进行开发\n* Blender - 使用Python作为建模工具与GUI语言的开源3D绘图软件\n* Inkscape - 一个开源的SVG矢量图形编辑器。\n* …\n\n---\n## Python3环境搭建\n本章节我们将向大家介绍如何在本地搭建 Python3 开发环境。\nPython3 可应用于多平台包括 Windows、Linux 和 Mac OS X。\n* Unix (Solaris, Linux, FreeBSD, AIX, HP/UX, SunOS, IRIX, 等等。)\n* Win 9x/NT/2000\n* Macintosh (Intel, PPC, 68K)\n* OS/2\n* DOS (多个DOS版本)\n* PalmOS\n* Nokia 移动手机\n* Windows CE\n* Acorn/RISC OS\n* BeOS\n* Amiga\n* VMS/OpenVMS\n* QNX\n* VxWorks\n* Psion\n* Python 同样可以移植到 Java 和 .NET 虚拟机上。\n\n---\n## Python3 下载\nPython3 最新源码，二进制文档，新闻资讯等可以在 Python 的官网查看到：\nPython 官网： [https://www.python.org/](https://www.python.org/) \n你可以在以下链接中下载 Python 的文档，你可以下载 HTML、PDF 和 PostScript 等格式的文档。\nPython文档下载地址： [https://www.python.org/doc/](https://www.python.org/doc/) \n---\n## Python 安装\nPython 已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。\n您需要下载适用于您使用平台的二进制代码，然后安装 Python。\n如果您平台的二进制代码是不可用的，你需要使用C编译器手动编译源代码。\n编译的源代码，功能上有更多的选择性， 为 Python 安装提供了更多的灵活性。\n以下是各个平台安装包的下载地址：\n[image:44114F43-ECB0-489B-B712-7C17D143A61D-1233-0000B25E797A2B1D/F2135662-1078-4EE2-BEBB-353F8D8E521F.jpg]\n*Source Code*可用于 Linux 上的安装。\n以下为不同平台上安装 Python3 的方法。\n### *Unix & Linux 平台安装 Python3:*\n以下为在 Unix & Linux 平台上安装 Python 的简单步骤：\n* 打开WEB浏览器访问 [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/) \n* 选择适用于 Unix/Linux 的源码压缩包。\n* 下载及解压压缩包*Python-3.x.x.tgz*，*3.x.x*为你下载的对应版本号。\n* 如果你需要自定义一些选项修改/Modules/Setup/\n以*Python3.6.1*版本为例：\n```bash\n# tar -zxvf Python-3.6.1.tgz\n# cd Python-3.6.1\n# ./configure\n# make && make install\n```\n检查 Python3 是否正常可用：\n```bash\n# python3 -V\nPython 3.6.1\n```\n\n---\n## Python3 基础语法\n### *编码*\n默认情况下，Python 3 源码文件以*UTF-8*编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：\n```bash\n# -*- coding: cp-1252 -*-\n```\n上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。\n---\n## *标识符*\n* 第一个字符必须是字母表中字母或下划线*_*。\n* 标识符的其他的部分由字母、数字和下划线组成。\n* 标识符对大小写敏感。\n在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。\n---\n## *python保留字*\n保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：\n```bash\n>>> import keyword\n>>> keyword.kwlist\n['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n---\n## *注释*\nPython中单行注释以*#*开头，实例如下：\n```python\n#!/usr/bin/python3\n \n# 第一个注释\nprint (\"Hello, Python!\") # 第二个注释\n```\n执行以上代码，输出结果为：\n```bash\nHello, Python!\n```\n多行注释可以用多个*#*号，还有*’’’*和*”””*：\n```python\n#!/usr/bin/python3\n \n# 第一个注释\n# 第二个注释\n \n'''\n第三注释\n第四注释\n'''\n \n\"\"\"\n第五注释\n第六注释\n\"\"\"\nprint (\"Hello, Python!\")\n```\n执行以上代码，输出结果为：\n```bash\nHello, Python!\n```\n## *数字(Number)类型*\nPython中数字有四种类型：整数、布尔型、浮点数和复数。\n* *int*(整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\n* *bool*(布尔), 如 True。\n* *float*(浮点数), 如 1.23、3E-2\n* *complex*(复数), 如 1 + 2j、 1.1 + 2.2j\n---\n## *字符串(String)*\n* python中单引号和双引号使用完全相同。\n* 使用三引号(‘’’或”””)可以指定一个多行字符串。\n* 转义符 ‘\\’\n* 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。\n* 按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。\n* 字符串可以用 + 运算符连接在一起，用 * 运算符重复。\n* Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。\n* Python中的字符串不能改变。\n* Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。\n* 字符串的截取的语法格式如下：*变量[头下标:尾下标:步长]*\n```python\nword = '字符串'\nsentence = \"这是一个句子。\"\nparagraph = \"\"\"这是一个段落，\n可以由多行组成\"\"\"\n```\n\n```python\n#!/usr/bin/python3\n \nstr='Runoob'\n \nprint(str)                 # 输出字符串\nprint(str[0:-1])           # 输出第一个到倒数第二个的所有字符\nprint(str[0])              # 输出字符串第一个字符\nprint(str[2:5])            # 输出从第三个开始到第五个的字符\nprint(str[2:])             # 输出从第三个开始的后的所有字符\nprint(str * 2)             # 输出字符串两次\nprint(str + '你好')        # 连接字符串\n \nprint('------------------------------')\n \nprint('hello\\nrunoob')      # 使用反斜杠(\\)+n转义特殊字符\nprint(r'hello\\nrunoob')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义\n```\n这里的 r 指 raw，即 raw string。\n输出结果为：\n```bash\nRunoob\nRunoo\nR\nnoo\nnoob\nRunoobRunoob\nRunoob你好\n------------------------------\nhello\nrunoob\nhello\\nrunoob\n```\n\n---\n## 空行\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n*记住：*空行也是程序代码的一部分。\n---\n## 等待用户输入\n执行下面的程序在按回车键后就会等待用户输入：\n```python\n#!/usr/bin/python3\ninput(\"\\n\\n按下 enter 键后退出。\")\n```\n以上代码中 ，”\\n\\n”在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。\n---\n## 同一行显示多条语句\nPython可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：\n```python\n#!/usr/bin/python3\n \nimport sys; x = 'runoob'; sys.stdout.write(x + '\\n')\n```\n使用脚本执行以上代码，输出结果为：\n```bash\nrunoob\n```\n使用交互式命令行执行，输出结果为：\n```bash\n>>> import sys; x = 'runoob'; sys.stdout.write(x + '\\n')\nrunoob\n7\n```\n此处的 7 表示字符数。\n---\n## 多个语句构成代码组\n缩进相同的一组语句构成一个代码块，我们称之代码组。\n像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。\n我们将首行及后面的代码组称为一个子句(clause)。\n如下实例：\n```bash\nif expression : \n   suite\nelif expression : \n   suite \nelse : \n   suite\n```\n---\n## Print 输出\nPrint 默认输出是换行的，如果要实现不换行需要在变量末尾加上*end=“”*：\n```python\n#!/usr/bin/python3\n \nx=\"a\"\ny=\"b\"\n# 换行输出\nprint( x )\nprint( y )\n \nprint('---------')\n# 不换行输出\nprint( x, end=\" \" )\nprint( y, end=\" \" )\nprint()\n```\n以上实例执行结果为：\n```bash\na\nb\n---------\na b\n```\n---\n## import 与 from…import\n在 python 用*import*或者*from…import*来导入相应的模块。\n将整个模块(somemodule)导入，格式为：*import somemodule*\n从某个模块中导入某个函数,格式为：*from somemodule import somefunction*\n从某个模块中导入多个函数,格式为：*from somemodule import firstfunc, secondfunc, thirdfunc*\n将某个模块中的全部函数导入，格式为：*from somemodule import **\n\n## 命令行参数\n很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：\n```bash\n$ python -h\nusage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...\nOptions and arguments (and corresponding environment variables):\n-c cmd : program passed in as string (terminates option list)\n-d     : debug output from parser (also PYTHONDEBUG=x)\n-E     : ignore environment variables (such as PYTHONPATH)\n-h     : print this help message and exit\n\n[ etc. ]\n```\n\n---\n## Python3 基本数据类型\nPython 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。\n等号（=）用来给变量赋值。\n等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：\n```python\n#!/usr/bin/python3\n \ncounter = 100          # 整型变量\nmiles   = 1000.0       # 浮点型变量\nname    = \"runoob\"     # 字符串\n \nprint (counter)\nprint (miles)\nprint (name)\n```\n执行以上程序会输出如下结果：\n```bash\n100\n1000.0\nrunoob\n```\n\n### 多个变量赋值\nPython允许你同时为多个变量赋值。例如：\n```bash\na = b = c = 1\n```\n以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。\n您也可以为多个对象指定多个变量。例如：\n```bash\na, b, c = 1, 2, \"runoob\"\n```\n以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob” 分配给变量 c。\n---\n## 标准数据类型\nPython3 中有六个标准的数据类型：\n* Number（数字）\n* String（字符串）\n* List（列表）\n* Tuple（元组）\n* Set（集合）\n* Dictionary（字典）\nPython3 的六个标准数据类型中：\n* *不可变数据（3 个）：*Number（数字）、String（字符串）、Tuple（元组）；\n* *可变数据（3 个）：*List（列表）、Dictionary（字典）、Set（集合）。\n---\n## Number（数字)\nPython3 支持*int、float、bool、complex（复数）*。\n在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。\n像大多数语言一样，数值类型的赋值和计算都是很直观的。\n内置的 type() 函数可以用来查询变量所指的对象类型。\n```bash\n>>> a, b, c, d = 20, 5.5, True, 4+3j\n>>> print(type(a), type(b), type(c), type(d))\n<class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n```\n此外还可以用 isinstance 来判断：\n```bash\n>>>a = 111\n>>> isinstance(a, int)\nTrue\n>>>\n```\nisinstance 和 type 的区别在于：\n* type()不会认为子类是一种父类类型。\n* isinstance()会认为子类是一种父类类型。\n```bash\n>>> class A:\n...     pass\n... \n>>> class B(A):\n...     pass\n... \n>>> isinstance(A(), A)\nTrue\n>>> type(A()) == A \nTrue\n>>> isinstance(B(), A)\nTrue\n>>> type(B()) == A\nFalse\n```\n\n> *注意：*/在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。/\n\n当你指定一个值时，Number 对象就会被创建：\n```bash\nvar1 = 1\nvar2 = 10\n```\n您也可以使用del语句删除一些对象引用。\nDel语句的语法是：\n```bash\ndel var1[,var2[,var3[....,varN]]]\n```\n您可以通过使用del语句删除单个或多个对象。例如：\n```bash\ndel var\ndel var_a, var_b\n```\n\n### 数值运算\n```bash\n>>>5 + 4  # 加法\n9\n>>> 4.3 - 2 # 减法\n2.3\n>>> 3 * 7  # 乘法\n21\n>>> 2 / 4  # 除法，得到一个浮点数\n0.5\n>>> 2 // 4 # 除法，得到一个整数\n0\n>>> 17 % 3 # 取余 \n2\n>>> 2 ** 5 # 乘方\n32\n```\n*注意：*\n* 1、Python可以同时为多个变量赋值，如a, b = 1, 2。\n* 2、一个变量可以通过赋值指向不同类型的对象。\n* 3、数值的除法包含两个运算符：*/*返回一个浮点数，*//*返回一个整数。\n* 4、在混合计算时，Python会把整型转换成为浮点数。\n\n---\n\n## String（字符串）\nPython中的字符串用单引号*’*或双引号*”*括起来，同时使用反斜杠*\\*转义特殊字符。\n字符串的截取的语法格式如下：\n```bash\n变量[头下标:尾下标]\n```\n\n索引值以 0 为开始值，-1 为从末尾的开始位置。\n[image:EE3153D1-04F7-4FFA-855F-673FB36369FB-1233-0000BD6157821813/o99aU.png]\n\n加号*+*是字符串的连接符， 星号***表示复制当前字符串，紧跟的数字为复制的次数。实例如下：\n\n```python\n#!/usr/bin/python3\n \nstr = 'Runoob'\n \nprint (str)          # 输出字符串\nprint (str[0:-1])    # 输出第一个到倒数第二个的所有字符\nprint (str[0])       # 输出字符串第一个字符\nprint (str[2:5])     # 输出从第三个开始到第五个的字符\nprint (str[2:])      # 输出从第三个开始的后的所有字符\nprint (str * 2)      # 输出字符串两次\nprint (str + \"TEST\") # 连接字符串\n```\n执行以上程序会输出如下结果：\n```bash\nRunoob\nRunoo\nR\nnoo\nnoob\nRunoobRunoob\nRunoobTEST\n```\n\n---\n## List（列表)\nList（列表） 是 Python 中使用最频繁的数据类型。\n列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。\n列表是写在方括号*[]*之间、用逗号分隔开的元素列表。\n和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。\n加号*+*是列表连接运算符，星号***是重复操作。如下实例：\n```python\n#!/usr/bin/python3\n \nlist = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]\ntinylist = [123, 'runoob']\n \nprint (list)            # 输出完整列表\nprint (list[0])         # 输出列表第一个元素\nprint (list[1:3])       # 从第二个开始输出到第三个元素\nprint (list[2:])        # 输出从第三个元素开始的所有元素\nprint (tinylist * 2)    # 输出两次列表\nprint (list + tinylist) # 连接列表\n```\n以上实例输出结果：\n```bash\n['abcd', 786, 2.23, 'runoob', 70.2]\nabcd\n[786, 2.23]\n[2.23, 'runoob', 70.2]\n[123, 'runoob', 123, 'runoob']\n['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob']\n```\n*注意：*\n* 1、List写在方括号之间，元素用逗号隔开。\n* 2、和字符串一样，list可以被索引和切片。\n* 3、List可以使用+操作符进行拼接。\n* 4、List中的元素是可以改变的。\n\n如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：\n```python\n*def*reverseWords(input):\n  \n # 通过空格将字符串分隔符，把各个单词分隔为列表\n  inputWords=input.split(\" \")\n\n # 翻转字符串\n # 假设列表 list = [1,2,3,4], \n # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)\n # inputWords[-1::-1] 有三个参数\n # 第一个参数 -1 表示最后一个元素\n # 第二个参数为空，表示移动到列表末尾\n # 第三个参数为步长，-1 表示逆向\n  inputWords=inputWords[-1::-1]\n\n # 重新组合字符串\n  output=' '.join(inputWords)\n  \n *return*output\n\n*if*__name__==\"__main__\":\n input='I like runoob'\n  rw=reverseWords(input)\n *print*(rw)\n```\n输出结果为：\n```bash\nrunoob like I\n```\n---\n## Tuple（元组）\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号*()*里，元素之间用逗号隔开。\n元组中的元素类型也可以不相同：\n\n```python\n#!/usr/bin/python3\n \ntuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )\ntinytuple = (123, 'runoob')\n \nprint (tuple)             # 输出完整元组\nprint (tuple[0])          # 输出元组的第一个元素\nprint (tuple[1:3])        # 输出从第二个元素开始到第三个元素\nprint (tuple[2:])         # 输出从第三个元素开始的所有元素\nprint (tinytuple * 2)     # 输出两次元组\nprint (tuple + tinytuple) # 连接元组\n```\n以上实例输出结果：\n```bash\n('abcd', 786, 2.23, 'runoob', 70.2)\nabcd\n(786, 2.23)\n(2.23, 'runoob', 70.2)\n(123, 'runoob', 123, 'runoob')\n('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')\n```\n元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。\n其实，可以把字符串看作一种特殊的元组。\n\nstring、list 和 tuple 都属于 sequence（序列）。\n*注意：*\n* 1、与字符串一样，元组的元素不能修改。\n* 2、元组也可以被索引和切片，方法一样。\n* 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。\n* 4、元组也可以使用+操作符进行拼接。\n---\n## Set（集合）\n集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。\n基本功能是进行成员关系测试和删除重复元素。\n可以使用大括号*{ }*或者*set()*函数创建集合，注意：创建一个空集合必须用*set()*而不是*{ }*，因为*{ }*是用来创建一个空字典。\n```python\n#!/usr/bin/python3\n \nstudent = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}\n \nprint(student)   # 输出集合，重复的元素被自动去掉\n \n# 成员测试\nif 'Rose' in student :\n    print('Rose 在集合中')\nelse :\n    print('Rose 不在集合中')\n \n \n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n \nprint(a)\n \nprint(a - b)     # a 和 b 的差集\n \nprint(a | b)     # a 和 b 的并集\n \nprint(a & b)     # a 和 b 的交集\n \nprint(a ^ b)     # a 和 b 中不同时存在的元素\n```\n以上实例输出结果：\n```bash\n{'Mary', 'Jim', 'Rose', 'Jack', 'Tom'}\nRose 在集合中\n{'b', 'a', 'c', 'r', 'd'}\n{'b', 'd', 'r'}\n{'l', 'r', 'a', 'c', 'z', 'm', 'b', 'd'}\n{'a', 'c'}\n{'l', 'r', 'z', 'm', 'b', 'd'}\n```\n---\n## Dictionary（字典）\n字典（dictionary）是Python中另一个非常有用的内置数据类型。\n列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。\n字典是一种映射类型，字典用*{ }*标识，它是一个无序的*键(key) : 值(value)*的集合。\n键(key)必须使用不可变类型。\n在同一个字典中，键(key)必须是唯一的。\n```python\n#!/usr/bin/python3\n \ndict = {}\ndict['one'] = \"1 - 菜鸟教程\"\ndict[2]     = \"2 - 菜鸟工具\"\n \ntinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}\n \n \nprint (dict['one'])       # 输出键为 'one' 的值\nprint (dict[2])           # 输出键为 2 的值\nprint (tinydict)          # 输出完整的字典\nprint (tinydict.keys())   # 输出所有键\nprint (tinydict.values()) # 输出所有值\n```\n以上实例输出结果：\n```bash\n1 - 菜鸟教程\n2 - 菜鸟工具\n{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}\ndict_keys(['name', 'code', 'site'])\ndict_values(['runoob', 1, 'www.runoob.com'])\n```\n\n另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。\n*注意：*\n* 1、字典是一种映射类型，它的元素是键值对。\n* 2、字典的关键字必须为不可变类型，且不能重复。\n* 3、创建空字典使用*{ }*。\n---\n","tags":["python"],"categories":["python"]},{"title":"Python常用命令— virtualenv","url":"/2019/11/20/Python常用命令—-virtualenv/","content":"1. 创建虚拟环境：\n```bash\nvirtualenv venv\nvirtualenv --no-site-packages venv\n```\n\n> 其中—no-site-packages 会创建一个纯净的虚拟环境，不会安装任何安装包\n\n2. 激活虚拟环境（编译器路径被暂时加入到了PATH中）：\nlinux下：source venv/bin/activate\n3. 取消激活\n激活只是对当前的console窗口有效，可以发现激活以后，命令行头部多了 (venv)。取消激活可以执行如下命令：\n```bash\n$source venv/bin/deactivate\n```\n4. 删除虚拟环境\n\n要删除一个虚拟环境，只需删除它的文件夹。（执行 rm -rf venv ）。","tags":["python"],"categories":["python"]},{"title":"django教程","url":"/2019/11/20/django教程/","content":"## 查看当前python所依赖的包\n```bash\n╰$ pip list\nPackage           Version\n----------------- -------\npbr               5.4.3\npip               19.3.1\npytz              2019.3\nsetuptools        39.2.0\nsix               1.12.0\nsqlparse          0.3.0\nstevedore         1.31.0\nvirtualenv        16.7.6\nvirtualenv-clone  0.5.3\nvirtualenvwrapper 4.8.4\nwheel             0.31.1\n```\n## 创建独立环境\n```bash\n╰$ virtualenv test\nUsing base prefix '/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6'\nNew python executable in /Users/shiyuxiang/develop/python/test/bin/python3.6\nAlso creating executable in /Users/shiyuxiang/develop/python/test/bin/python\nInstalling setuptools, pip, wheel...\ndone.\n```\n## 开启独立环境\n```bash\n╭─shiyuxiang@localhost in ~/develop/python\n╰$ ls\nMyblog   blog     test     tutorial\n╭─shiyuxiang@localhost in ~/develop/python\n╰$ cd test\n╭─shiyuxiang@localhost in ~/develop/python/test\n╰$ ls\nbin     include lib\n╭─shiyuxiang@localhost in ~/develop/python/test\n╰$ source bin/activate\n(test) ╭─shiyuxiang@localhost in ~/develop/python/test\n╰$\n```\n## 安装django\n```bash\n(test) ╭─shiyuxiang@localhost in ~/develop/python/test\n╰$ pip install django==1.11.7\nCollecting django==1.11.7\n  Using cached https://files.pythonhosted.org/packages/15/d8/b17afdcd527026d2f1acd30ac33406e6b22c0f573a3c14b2d9e0bd7df945/Django-1.11.7-py2.py3-none-any.whl\nCollecting pytz\n  Using cached https://files.pythonhosted.org/packages/e7/f9/f0b53f88060247251bf481fa6ea62cd0d25bf1b11a87888e53ce5b7c8ad2/pytz-2019.3-py2.py3-none-any.whl\nInstalling collected packages: pytz, django\nSuccessfully installed django-1.11.7 pytz-2019.3\n```\n## 创建并启动\n```bash\n创建\ndjango-admin startproject mysite\n\n运行\npython manage.py runserver 127.0.0.1:8001\n\n浏览器访问：\nhttp://127.0.0.1:8001\n```\n## 查看目录结构\n```bash\nmysite　　　　#目录\n　- mysite      # 对整个程序进行配置\n　　- init\n　　- settings  # 配置文件\n　　- urls       # URL对应关系\n　　- wsgi      # 遵循WSIG规范，uwsgi + nginx\n - manage.py     # 管理Django程序：\n```\n## 创建app\n```bash\npython manage.py startapp cmdb     -->Terminal里面运行\n```\n## app目录结构\n```bash\n# 目录结构\n- cmdb\n    - migrations　　#数据库操作记录（只是修改表结构的记录）\n    - init　　　　　　#表示python数据包（python3中有无均可）\n    - admin　　　　　　#Django为我们提供的后台管理\n    - apps　　　　　　#配置当前app\n    - models　　　　　#创建数据库表结构，写指定的类，通过命令可以创建数据库结构\n    - tests　　　　　　#单元测试\n    - views　　　　　　#写业务逻辑代码，最重要的就是这个文件了\n```\n","tags":["django"],"categories":["django"]},{"title":"djangoAPI接口的开发","url":"/2019/11/20/djangoAPI接口的开发/","content":"## 配置开发环境\n```python\npip install djangorestframework\n```\n## 在项目中添加rest_framework\n```python\nINSTALLED_APPS = ( \n    ...\n    'rest_framework',\n)\n```\n## 编写model层\n```python\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=50)\n    price = models.DecimalField(max_digits=8,decimal_places=2\n\n    def __str__(self):\n          return self.name\n```\n## 配置数据库\n```python\npython manage.py makemigratons\npython manage.py migrate\n```\n## 编写序列化模块\n```python\nfrom rest_framework import serializers\nfrom .models import Product\n\nclass ProductSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Product\n        fields = (\"id\",\"name\",\"price\")\n```\n## 编写视图\n```python\nfrom rest_framework.views import APIView\nfrom rest_framework import generics\n\nfrom .models import Product\nfrom .serializers import ProductSerializer\n\n# 使用APIView\nclass ProductView(APIView):\n    def get(self, request, format=None):\n        product = Product.objects.all()\n        serializer = ProductSerializer(product, many=True)\n        return Response(serializer.data)\n\n    def post(self, request, format=None):\n        serializer = ProductSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        else:\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n```\n## 编写路由\n```python\nfrom django.conf.urls import  url\nfrom . import views\n\nurlpatterns = [\n    url(r'^api/$', views.ProductView.as_view(), name='product'),\n]\n```","tags":["django api开发"],"categories":["django api开发"]},{"title":"linux安装lnmp","url":"/2019/11/19/linux安装lnmp/","content":"## 安装nginx\n\n```bash\nyum install nginx\n# 开启nginx\nservice nginx start\n```\n\n## 安装MYSQL\n\n### 更新yum源\n\n```bash\nyum localinstall http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm\n\nyum install mysql-community-server\n```\n### 开启mysql\n```bash\nservice mysqld start\n```\n### 查看mysql的root账号的密码\n```bash\ngrep 'temporary password' /var/log/mysqld.log\n```\n### 登录mysql\n```bash\nmysql -uroot -p\n```\n### 修改密码\n```bash\nALTER USER 'root'@'localhost' IDENTIFIED BY 'password';\n```\n### 修改root用户可远程登录\n```bash\n# 有问题\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\n```\n### 刷新\n```bash\nflush privileges;\n```\n\n## mysql安全策略\n### 查看现在的密码策略：\n```bash\nshow variables like 'validate_password%';\n```\n----\nvalidate_password_number_count参数是密码中至少含有的数字个数，当密码策略是MEDIUM或以上时生效。\n\nvalidate_password_special_char_count参数是密码中非英文数字等特殊字符的个数，当密码策略是MEDIUM或以上时生效。\n\nvalidate_password_mixed_case_count参数是密码中英文字符大小写的个数，当密码策略是MEDIUM或以上时生效。\n\nvalidate_password_length参数是密码的长度，这个参数由下面的公式生成\n\nvalidate_password_number_count+ validate_password_special_char_count+ (2 * validate_password_mixed_case_count)\n\nvalidate_password_dictionary_file参数是指定密码验证的字典文件路径。\n\nvalidate_password_policy这个参数可以设为0、1、2，分别代表从低到高的密码强度，此参数的默认值为1，如果想将密码强度改弱，则更改此参数为0。\n\n-----\n\n## 更改密码策略，降低密码的验证标准\n### 更改密码策略为LOW\n```bash\nset global validate_password_policy=0;\n```\n### 更改密码长度\n```bash\nset global validate_password_length=0;\n```\n### 密码最小长度为4\n```bash\nSHOW VARIABLES LIKE 'validate_password%';\n```\n## 安装php\n### 安装yum源\n```bash\nrpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n\nrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n\n```\n### 查看\n```bash\nyum search php71w\n```\n### 安装php以及扩展\n```bash\nyum install php71w php71w-fpm php71w-cli php71w-common php71w-devel php71w-gd php71w-pdo php71w-mysql php71w-mbstring php71w-bcmath\n```\n### 开启服务\n```bash\nservice php-fpm start\n```\n\n","tags":["PHP","nginx","MySQL"],"categories":["PHP","nginx"]},{"title":"SSH免密登录","url":"/2019/11/17/SSH免密登录/","content":"## 什么是ssh？\nSSH 为 [Secure Shell](https://baike.baidu.com/item/Secure%20Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为 [远程登录](https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/1071998) 会话和其他网络服务提供安全性的协议。\n## 如何快速的配置ssh免密登录\n### 配置ssh分三步走\n1.  在本地创建公私钥\n```bash\nssh-keygen -t rsa #加密方式选 rsa|dsa均可以，默认dsa\n-t #The type of the key to generate 密钥的类型\n-C #comment to identify the key 用于识别这个密钥的注释 \n\n$ ssh-keygen -t rsa  #加密方式选 rsa|dsa均可以，默认dsa -t The type of the key to generate 密钥的类型 -C comment to identify the key 用于识别这个密钥的注释\nGenerating public/private rsa key pair.\nEnter file *in* which to save the key (/c/Users/Administrator/.ssh/id_rsa):\nEnter passphrase (empty *for* no passphrase):\nEnter same passphrase again:\nYour identification has been saved *in* /c/Users/Administrator/.ssh/id_rsa.\nYour public key has been saved *in* /c/Users/Administrator/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:gygJuDyfHDsL3n7HoNxXKNrjelXTKjQ1FgvXBVuoR/g geek@PC-20190414MTRE\nThe key's randomart image is:\n+---[RSA 2048]----+\n|       . o+.+o   |\n|.       o=.+o    |\n|o       o.*.     |\n|.o . . + + E     |\n|.oo.. o S +      |\n|  +.+o + +       |\n| ..*= = o        |\n|. o+o* +         |\n| ..==.+          |\n+----[SHA256]-----+\n```\n2. 用ssh-copy-id 将公钥复制或传输到远程服务器,并将身份标识文件追加到服务器的\n```bash\n$ ssh-copy-id -i ~/.ssh/yuxiangServer.pub usaename@ip\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \n\"/c/Users/Administrator/.ssh/id_rsa.pub\"\n/usr/bin/ssh-copy-id: INFO: attempting to log *in* with the new key(s), to filter \nout any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- *if* you are prompted \nnow it is to install the new keys\nyuxiangshi@119.23.78.131's password:\nNumber of key(s) added: 1\nNow try logging into the machine, with:   \"ssh 'yuxiangshi@119.23.78.131'\"\nand check to make sure that only the key(s) you wanted were added.\n```\n3. 配置本机ssh config文件\n```bash\nHost yuxiangServer\n      HostName 119.23.78.131\n      User yuxiangshi\n      Port 22\n      PubkeyAuthentication yes \n      IdentityFile ~/.ssh\n```\n* 修改服务器 /etc/ssh/sshd_config,并重启sshd服务\n```bash\nRSAAuthentication yes \nPubkeyAuthentication yes \nAuthorizedKeysFile      ~/.ssh/authorized_keys\n```\n愉快的玩耍吧。","tags":["工具 ssh"]},{"title":"php-fpm常用命令","url":"/2019/11/17/hello-world/","content":"* 查看php-fpm端口是否在被php-fpm使用\n```bash\nsudo lsof -i:9000\n```\n* 一般修改 php.ini 文件后经常需要重启php-fpm\n```bash\nsudo  killall  php-fpm   关闭\n```\n* 再输入 sudo lsof -i:9000 就会发现php-fpm没有打印对应端口\n```bash\nsudo  php-fpm    重启\n```","tags":["php-fpm"]}]